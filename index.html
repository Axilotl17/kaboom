<!DOCTYPE html>
<html>
    <head>
        <title>Kaboom!</title>
    </head>
    <body>
        <table>
            <tr>
                <td>
                    <div id = "board" class = "item">
                        <canvas id="minefield" width="1600" height="1600" class = "divider"></canvas> 
                    </div>
                </td>
                <td width="100%">
                    <div id = "info" class = "item">
                        <p id = "time">00:00.00</p>
                        <p id = "flags">üè≥</p>
                        <button onclick="setToggle()" class="button-50" role="button">Settings ‚öô</button>
                </td>
                <td>
                    <div id = "leaderboard" class = "item">
                    </div>
                </td>
            </tr>
        </table>
        <div id = "settings">
            <div id = "container">
                <p class = setting>
                    <input type="radio" id="count" name="mines" onclick="radio(true)"> Mine #: 
                    <input type="number" size=6 min=0 value =10>
                </p>
                <p class = setting>
                    <input type="radio" id="percent" name="mines" onclick="radio(false)"> Mine %: 
                    <input type="number" size=6 max=100 min=0 value =15> %
                </p>
                <p class = setting>
                    Minefield size: 
                    <input id = "dimInput" type="number" size=6 max=100 min=0 value =8>
                </p>
                <button id = "btnx" onclick="setToggle()"><p id = "btnxp">x</p></button>
            </div> 
        </div>
    </body>
    <style>
        .button-50 {
        appearance: button;
        background-color: #000;
        background-image: none;
        border: 1px solid #000;
        border-radius: 4px;
        box-shadow: #fff 4px 4px 0 0,#000 4px 4px 0 1px;
        box-sizing: border-box;
        color: #fff;
        cursor: pointer;
        display: inline-block;
        font-family: ITCAvantGardeStd-Bk,Arial,sans-serif;
        font-size: 14px;
        font-weight: 400;
        line-height: 20px;
        margin: 0 5px 10px 0;
        overflow: visible;
        padding: 8px 20px;
        text-align: center;
        text-transform: none;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        vertical-align: middle;
        white-space: nowrap;
        }

        .button-50:focus {
        text-decoration: none;
        }

        .button-50:hover {
        text-decoration: none;
        }

        .button-50:active {
        box-shadow: rgba(0, 0, 0, .125) 0 3px 5px inset;
        outline: 0;
        }

        .button-50:not([disabled]):active {
        box-shadow: #fff 2px 2px 0 0, #000 2px 2px 0 1px;
        transform: translate(2px, 2px);
        }

        @media (min-width: 768px) {
        .button-50 {
            padding: 8px 20px;
        }
        }
        #btnxp {
            position: relative;
            top:-1.6px;
            padding: 0px;
            margin: 0px;
            font-weight: bolder;
        }
        #btnx {
            position: absolute;
            left: -12px;
            top: -12px;
            line-height: 1em;
            padding: 0px;
            padding-top: -5px;
            text-align: center;
            display:block;
            height: 25px;
            width: 25px;
            border-radius: 50%;
            background-color: red;
            border: 3px solid black;
            cursor:pointer;
        }
        body {
            margin: 0;
        }
        #settings {
            position:absolute;
            top: 0;
            left:0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,.2);
            display: none;
        }
        #container {
            position: fixed;
            left: 30%;
            top: 25%;
            width: 40%;
            height: 50%;
            min-height: 250px;
            border:4px solid #000000;
            border-radius: 8px;
            background: rgb(255,255,255);
            padding: 8px;
        }
        td {
            vertical-align: top;
        }
        #leaderboard {
            text-align: right
        }
        #info {
            margin-left: 20px;
        }
        .item {
            vertical-align:top
        }
        #minefield {
            border:1px solid #000000;
        }
        p {
            font-family: Andale Mono, AndaleMono, monospace;
        }
        .setting {
            margin: 8px;
        }


    </style>
    <script>
        const minefield = document.getElementById("minefield");
        const minefieldDim = (window.innerHeight-14) 
        const flagCounter = document.getElementById("flags")
        const settings = document.getElementById("settings");
        var ctx = minefield.getContext("2d");
        var firstClick = true
        var mineCount = 10
        var dimension = document.getElementById("dimInput").value
        var board = []
        var stat = []
        var cursorX
        var cursorY
        var boxX
        var boxY
        var game = "pre"
        var startTime = 0
        var flagCount = 0
        var finalTime = 0 

        minefield.style.height = minefieldDim.toString()+"px"
        minefield.style.width = minefieldDim.toString()+"px"
        window.focus();
        minefield.oncontextmenu = function(e) { e.preventDefault(); e.stopPropagation(); }

        if(localStorage.getItem('config') != null) {
            if(JSON.parse(localStorage.getItem('config')).constructor != Object) {
                localStorage.setItem('config', JSON.stringify({}))
            }
        } else {
            localStorage.setItem('config', JSON.stringify({
                "mineCount": 10,
                "minePercent": 15,
                "count": true,
                "size":8
            }))
        }

        if(localStorage.getItem('leaderboard') != null) {
            if(JSON.parse(localStorage.getItem('leaderboard')).constructor != Object) {
                localStorage.setItem('leaderboard', JSON.stringify({}))
            }
        } else {
            localStorage.setItem('leaderboard', JSON.stringify({}))
        }
        var leaderboard = JSON.parse(localStorage.getItem('leaderboard'))

        let checks = false
        document.getElementsByName("mines").forEach(element => {
        checks = (!checks || element.checked) ? true : false
        })
        if(!checks) {
            document.getElementById("count").checked = true
            radio(true)
        } else {
            radio(document.getElementById("count").checked)
        }

        if(document.getElementById("count").checked) {
            mineCount = parseInt(document.getElementById("count").parentElement.children[1].value)
        } else if (document.getElementById("percent").checked) {
            mineCount = Math.round((dimension*dimension) * (parseInt(document.getElementById("percent").parentElement.children[1].value) / 100))
        }
        flagCounter.innerHTML = `üè≥ 0/${mineCount}`

        favicon()
        drawGrid()
        settings.style.display = "none"

        for (i = 0; i < dimension; i++){
            let line = []     
            for (j = 0; j < dimension; j++){
                line.push(0)
            }
            board.push(line)
        }

        for (i = 0; i < dimension; i++){
            let line = []     
            for (j = 0; j < dimension; j++){
                line.push(false)
            }
            stat.push(line)
        }

        if(leaderboard[currentLb()] == undefined) {
            leaderboard[currentLb()] = []
        }
        leaderboard[currentLb()].slice(0,10).forEach(element => {
        p = document.createElement('p')
        p.innerHTML = formatTimeElapsed(element)
        p.class = "times"
        document.getElementById('leaderboard').append(p)
        })
        

        function randNum(lim) {
            return Math.floor((Math.random()*lim))
        }

        function compare(a, b) {
            return(a.length === b.length && a.every((element, index) => element === b[index]))
        }

        function containsList(parent, child) {
            let contains = false
            parent.forEach(element => {
                if(compare(element, child)) {
                    contains = true
                }
            });
            return contains
        }

        function currentLb() {
            return `${dimension}x${mineCount}`
        }

        function formatTimeElapsed(time, timer) {
            if (startTime == 0 && timer) {
                return "00:00.000"
            }
            // Date.now() - startTime;
            const minutes = Math.floor(time / (60 * 1000));
            const seconds = Math.floor((time % (60 * 1000)) / 1000);
            const milliseconds = Math.floor((time % 1000));
            const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            return formattedTime;
        }

        function favicon() {
            var canvas = document.createElement('canvas');
            canvas.width = 32;canvas.height = 32;
            var fav = canvas.getContext('2d');
            var img = new Image();
            img.src = '/favicon.ico';

            fav.drawImage(img, 0, 0);
            fav.lineWidth = 2.7
            fav.beginPath()
            fav.fillStyle = 'red'
            fav.strokeStyle = 'red'
            fav.arc(
                        (.5)*(32),
                        (.5)*(32),
                        .4*(32),
                        0,
                        2 * Math.PI
                    )
            fav.stroke()
            fav.fill()
            fav.closePath()
            fav.beginPath()
            fav.strokeStyle = 'black'
            fav.arc(
                        (.5)*(32),
                        (.5)*(32),
                        .2*(32),
                        0,
                        2 * Math.PI
                    )
            fav.stroke()
            for (let i=0; i<6; i++) {
                line(
                    (.2*Math.cos((Math.PI/6)+i*(Math.PI/3))+.5)*(32),
                    (.2*Math.sin((Math.PI/6)+i*(Math.PI/3))+.5)*(32),
                    (.3*Math.cos((Math.PI/6)+i*(Math.PI/3))+.5)*(32),
                    (.3*Math.sin((Math.PI/6)+i*(Math.PI/3))+.5)*(32),
                    true,
                    fav
                )
            }
            fav.closePath()

            var link = document.createElement('link');
            link.type = 'image/x-icon';
            link.rel = 'shortcut icon';
            link.href = canvas.toDataURL("image/x-icon");
            document.getElementsByTagName('head')[0].appendChild(link);
        }

        function radio(count) {
            document.getElementById("count").parentElement.children[1].disabled = !count
            document.getElementById("percent").parentElement.children[1].disabled = count
        }

        function propagate(xo,yo) {
            if((dimension*dimension) - (9 + mineCount) < 0) {
                mineCount = ((dimension*dimension) - 9)
            }
            for (i = 0; i <= (mineCount-1); i++){
                let box = [randNum(dimension), randNum(dimension)]
                let range = []
                let clear = true
                for (let y = -1; y < 2; y++) {
                    if(yo+y >= 0 && yo+y < dimension) {
                        for (let x = -1; x < 2; x++) {
                            if(xo+x >= 0 && xo+x < dimension) {
                                range.push([(xo+x), (yo+y)])
                            }
                        }
                    }
                }
                while(board[box[1]][box[0]] == 9 || containsList(range, [(box[0]), (box[1])])) {
                    box = [randNum(dimension), randNum(dimension)]
                }
                board[box[1]][box[0]] = 9
                for (let y = -1; y < 2; y++) {
                    if(box[1]+y >= 0 && box[1]+y <= (dimension-1)) {
                        for (let x = -1; x < 2; x++) {
                            if(box[0]+x >= 0 && box[0]+x < dimension) {
                                if(board[box[1]+y][box[0]+x] != 9) {
                                    board[box[1]+y][box[0]+x]++
                                }
                            }
                        }
                    }
                }
            }
            game = "during"
        }

        /**
         * @param {num} x1
         * @param {num} y1
         * @param {num} x2
         * @param {num} y2
         */
        function line(x1, y1, x2, y2, round, canv) {
            if(!canv) {
                canv = ctx
            }
            canv.beginPath(); 
            if(round){ctx.lineCap = "round"}
            canv.moveTo(x1, y1);
            canv.lineTo(x2, y2);
            canv.stroke();
            canv.closePath();
        }

        function drawGrid(){
            ctx.lineWidth = 1.5
            for (i = 1; i < dimension; i++) {
                let width = minefield.width
                let size = width/dimension
                line(i*size, 0, i*size, width)
                line(0, i*size, width, i*size)
                line(i*size, 0, i*size, width)
                line(0, i*size, width, i*size)
            }
        }

        function draw(x, y) {
            stat[y][x] = true
            ctx.beginPath(); 
            ctx.fillStyle = `rgb(
                ${220-((25/5)*board[y][x])},
                ${220-((180/5)*board[y][x])}, 
                ${220-((180/5)*board[y][x])}
                )`
            ctx.fillRect(
                ((x/dimension)*minefield.width), 
                ((y/dimension)*minefield.width), 
                (minefield.width/dimension), 
                (minefield.width/dimension)
                );
            ctx.textAlign = "center"
            ctx.font = `bold ${(.8)*(minefield.width/dimension)}px "Andale Mono", monospace`;
            ctx.fillStyle="black"
            if(board[y][x] != 9 && board[y][x] != 0) {
                ctx.fillText(
                    board[y][x],
                    (.5+x)*(minefield.width/dimension),
                    (.8+y)*(minefield.width/dimension)
                    )
            } else if (board[y][x] != 0) {
                ctx.lineWidth = minefield.width/(dimension*10)
                ctx.arc(
                    (.5+x)*(minefield.width/dimension),
                    (.5+y)*(minefield.width/dimension),
                    .2*(minefield.width/dimension),
                    0,
                    2 * Math.PI
                )
                ctx.stroke(); 
                for (let i=0; i<6; i++) {
                    line(
                        (.2*Math.cos((Math.PI/6)+i*(Math.PI/3))+x+.5)*(minefield.width/dimension),
                        (.2*Math.sin((Math.PI/6)+i*(Math.PI/3))+y+.5)*(minefield.width/dimension),
                        (.3*Math.cos((Math.PI/6)+i*(Math.PI/3))+x+.5)*(minefield.width/dimension),
                        (.3*Math.sin((Math.PI/6)+i*(Math.PI/3))+y+.5)*(minefield.width/dimension),
                        true
                    )
                }
                ctx.lineWidth = minefield.width/800
            }
            ctx.closePath();
        }

        function reveal(xo, yo, click) {
            if(stat[yo][xo] === false){
                draw(xo, yo)
            } else if (stat[yo][xo] == "flag" && click === false){
                stat[yo][xo] = false
                draw(xo, yo)
            }
            if (board[yo][xo] == 9 && stat[yo][xo] != "flag") {
                lose()
            }
            if (board[yo][xo] == 0) {
                for (let y = -1; y < 2; y++) {
                    if(yo+y >= 0 && yo+y < dimension) {
                        for (let x = -1; x < 2; x++) {
                            if(xo+x >= 0 && xo+x < dimension) {
                                if(stat[yo+y][xo+x] === false || stat[yo+y][xo+x] === "flag"){
                                    reveal(xo+x, yo+y, false)
                                }
                            }
                        }
                    }
                }
            } else if (board[yo][xo] != "m" && click) {
                let flags = 0
                for (let y = -1; y < 2; y++) {
                    if(yo+y >= 0 && yo+y < dimension) {
                        for (let x = -1; x < 2; x++) {
                            if(xo+x >= 0 && xo+x < dimension) {
                                if(stat[yo+y][xo+x] === "flag"){
                                    flags++
                                }
                            }
                        }
                    }
                }
                if(flags == (board[yo][xo])) {
                    for (let y = -1; y < 2; y++) {
                        if(yo+y >= 0 && yo+y < dimension) {
                            for (let x = -1; x < 2; x++) {
                                if(xo+x >= 0 && xo+x < dimension) {
                                    if(stat[yo+y][xo+x] === false){
                                        reveal(xo+x, yo+y, false)
                                    }
                                }
                            }
                        }
                    }
                }
            }
            checkWin()
        }

        function flag(x,y, override) {
            if(stat[y][x] === false){
                stat[y][x] = "flag"
                updateFlags(1)
                ctx.beginPath()
                ctx.fillStyle="rgb(120,220,120)"
                ctx.fillRect(
                ((x/dimension)*minefield.width),
                ((y/dimension)*minefield.width),
                (minefield.width/dimension), 
                (minefield.width/dimension)
                );
                drawGrid()
                ctx.lineWidth = minefield.width/(dimension*10)
                line(
                    (.7+x)*(minefield.width/dimension),
                    (.2+y)*(minefield.width/dimension),
                    (.5+x)*(minefield.width/dimension),
                    (.8+y)*(minefield.width/dimension),
                    true
                )
                line(
                    (.7+x)*(minefield.width/dimension),
                    (.2+y)*(minefield.width/dimension),
                    (.3+x)*(minefield.width/dimension),
                    (.3+y)*(minefield.width/dimension),
                    true
                )
                line(
                    (.3+x)*(minefield.width/dimension),
                    (.3+y)*(minefield.width/dimension),
                    (.566+x)*(minefield.width/dimension),
                    (.6+y)*(minefield.width/dimension),
                    true
                )
                ctx.lineWidth = minefield.width/800

            } else if (stat[y][x] === "flag") {
                stat[y][x] = false
                updateFlags((-1))
                ctx.beginPath()
                ctx.fillStyle="white"
                ctx.fillRect(
                ((x/dimension)*minefield.width),
                ((y/dimension)*minefield.width),
                (minefield.width/dimension), 
                (minefield.width/dimension)
                );
                drawGrid()
            }

        }

        function check(x, y) {
            if(firstClick === true) {
                startTime = Date.now()
                propagate(x, y)
                firstClick = false
            }
            reveal(x, y, true)
            drawGrid()
        }

        function clickHandler(e) {
            let rect = minefield.getBoundingClientRect();
            let box = []
            box[0] = Math.floor(((e.clientX - rect.left)/minefieldDim)*dimension)
            box[1] = Math.floor(((e.clientY - rect.top)/minefieldDim)*dimension)
            switch (e.button) {
                case 0:
                    check(box[0], box[1])
                    break;
                case 1:
                    break;
                case 2:
                    flag(box[0], box[1])
                    break;
                default:
                    log.textContent = `Unknown button code: ${e.button}`;
            }
        }
        
        function tapHandler(e) {
            if (boxX != undefined && boxY !=undefined) {
                switch (e.key) {
                    case "z": 
                        check(boxX, boxY)
                        break;
                    case "x":
                        flag(boxX, boxY)
                        break;
    
                }
            }
        }

        function win() {
            endGame()
            ctx.fillStyle = 'rgb(120,220,120, 0.7)'
            ctx.fillRect(0, 0, minefield.width, minefield.width)
            ctx.fillStyle = 'rgb(0,0,0,1)'
            ctx.font = `bold ${.15*minefield.width}px Andale Mono`;
            ctx.fillText("You won!", .5*minefield.width, .35*minefield.width)
            ctx.font = `bold ${.09*minefield.width}px Andale Mono`;
            ctx.fillText(formatTimeElapsed(finalTime), .5*minefield.width, .5*minefield.width)
            ctx.font = `bold ${.05*minefield.width}px Andale Mono`;
            ctx.fillText("press [space] to try again.", .5*minefield.width, .6*minefield.width)
            addTime(finalTime)
        }

        function lose() {
            endGame()
            stat.forEach((row, y) => {
                row.forEach((item, x) => {
                    if (item == false) {
                        draw(x, y)
                    } else if (item == "flag" && board[y][x] != 9) {
                        draw(x, y)
                    }
                });
            });
            drawGrid()
            ctx.fillStyle = 'rgb(240,20,20,0.7)'
            ctx.fillRect(0, 0, minefield.width, minefield.width)
            ctx.fillStyle = 'rgb(0,0,0,1)'
            ctx.font = `bold ${.15*minefield.width}px Andale Mono`;
            ctx.fillText("You lost.", .5*minefield.width, .45*minefield.width)
            ctx.font = `bold ${.05*minefield.width}px Andale Mono`;
            ctx.fillText("press [space] to try again.", .5*minefield.width, .55*minefield.width)
        }
        
        function abort() {
            endGame()
            stat.forEach((row, y) => {
                row.forEach((item, x) => {
                    if (item == false) {
                        draw(x, y)
                    } else if (item == "flag" && board[y][x] != 9) {
                        draw(x, y)
                    }
                });
            });
            drawGrid()
            ctx.fillStyle = 'rgb(150,150,150,0.7)'
            ctx.fillRect(0, 0, minefield.width, minefield.width)
            ctx.fillStyle = 'rgb(0,0,0,1)'
            ctx.font = `bold ${.12*minefield.width}px Andale Mono`;
            ctx.fillText("Game aborted.", .5*minefield.width, .45*minefield.width)
            ctx.font = `bold ${.05*minefield.width}px Andale Mono`;
            ctx.fillText("press [space] to try again.", .5*minefield.width, .55*minefield.width)
        }

        function checkWin() {
            let complete
            if(game == "during") {
                complete == true
            } else {
                return
            }
            complete = true
            board.forEach((row, y) => {
                row.forEach((item, x) => {
                    if (item != 9 && stat[y][x] != true) {
                        complete = false
                    }
                });
            });
            if(complete) {
                board.forEach((row, y) => {
                    row.forEach((item, x) => {
                        if (item == 9 && stat[y][x] != "flag") {
                            flag(x, y, true)
                        }
                    });
                });
                win()
            }
        }

        function endGame() {
            clearInterval(updateTime)
            finalTime = Date.now() - startTime
            game = "over"
            minefield.removeEventListener('mousedown', clickHandler);
            window.removeEventListener('keydown', tapHandler);
            document.getElementById("time").innerHTML = formatTimeElapsed(finalTime)
        }

        function updateFlags(n) {
            flagCount += n 
            flagCounter.innerHTML = `üè≥ ${flagCount}/${mineCount}`
        }

        function logBoard () {
            for (j = 0; j < dimension; j++){
                console.log(board[j])
            }
            for (j = 0; j < dimension; j++){
                console.log(stat[j])
            }
        }

        function addTime(time) {
            leaderboard[currentLb()].push(time)
            leaderboard[currentLb()].sort(function(a, b){return a-b});
            if (leaderboard[currentLb()].length > 100) {
                leaderboard[currentLb()].length = 100
            }
            localStorage.setItem('leaderboard', JSON.stringify(leaderboard))
        }

        function setToggle() {
            if(settings.style.display == "none" ){
                settings.style.display = "block"
            } else {
                window.location.reload()
            }
        }

        minefield.addEventListener('mousedown', clickHandler)
        minefield.addEventListener('mousemove', function(e) {
            let rect = minefield.getBoundingClientRect();
            let box = []
            boxX = Math.floor(((e.clientX - rect.left)/minefieldDim)*dimension)
            boxY = Math.floor(((e.clientY - rect.top)/minefieldDim)*dimension)
        });
        minefield.addEventListener('mouseleave', function(e) {
            boxX = undefined
            boxY = undefined
        })
        window.addEventListener('keydown', function(e) {
            //console.log(e.key)
            switch (e.key) {
                case " ":
                    if(game == "over") {
                    window.location.reload()
                    } else if (game == "during") {
                        abort()
                    }
                    break;
                case "Escape":
                    setToggle()
                    break;
            }
        })
        window.addEventListener('keydown', tapHandler, true)

        const updateTime = setInterval(function() {
            document.getElementById("time").innerHTML = formatTimeElapsed(Date.now() - startTime, true)
        }, 1)
    </script>
</html>